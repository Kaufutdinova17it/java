# Лабораторная работа 3
# Вариант 5

## 1. Организация проекта и пакеты
*(Задачи "Навести порядок" и "Главный метод")*

Весь код организован в соответствии с требованием трехуровневого именования пакетов: `ru.фамилия.тип`. Вместо фамилии подставлена фамилия автора (`kaufutdinova`).

*   **ru.kaufutdinova.birds:**
    *   `Bird` (абстрактный класс)
    *   `Sparrow`, `Cuckoo`, `Parrot`
*   **ru.kaufutdinova.cities:**
    *   `City`
    *   `BidirectionalCity`
    *   `Route`
*   **ru.kaufutdinova.geometry:**
    *   `Point`
    *   `Point3D`
    *   `Line`
*   **ru.kaufutdinova.utils:**
    *   `Check` (валидация ввода)
    *   `ForPoint` (ввод координат)
    *   `MathUtils` (статический метод `power`)
*   **ru.kaufutdinova.main:**
    *   `Main` (точка входа в программу)

Точка входа находится только в классе `Main`, что соответствует условию задачи.

---

## 2. Работа с геометрическими объектами
*(Задачи "5 Трехмерная точка" и "4 4.2.4 Клонирование точки")*

В пакете `ru.kaufutdinova.geometry` реализована иерархия геометрических классов.

*   **Point (Точка):**
    *   Содержит координаты `x` и `y`.
    *   Переопределен метод `toString()` для удобного вывода.
    *   **Клонирование:** Переопределен метод `clone()`. Он использует `super.clone()`, что гарантирует создание копии, а не просто присваивание ссылки.

*   **Point3D (Трехмерная точка):**
    *   Наследуется от `Point` и добавляет координату `z`.
    *   Конструктор принимает три координаты.
    *   Переопределен `toString()` для вывода всех трех координат.
    *   **Клонирование:** Метод `clone()` переопределен для корректного клонирования трехмерной точки. Он вызывает `super.clone()` (копирует `x` и `y`), а затем явно копирует значение `z`.
    *   **Сравнение:** Переопределен метод `equals()`. Сначала сравнивается родительская часть (`super.equals(obj)`), затем добавляется сравнение координаты `z`.

*   **Line (Линия):**
    *   Содержит две точки (`start`, `end`).
    *   Имеет два конструктора: принимающий готовые точки и принимающий координаты для создания новых точек.
    *   Метод `length()` рассчитывает длину линии и округляет её до целого числа (`Math.round`).

**Демонстрация в `Main`:** Пользователю предлагается ввести координаты для 2D и 3D точек. Затем демонстрируется работа клонирования, сравнения и создания линии.

---

## 3. Моделирование дорожной сети
*(Задачи "10 Дороги", "5 Маршрут", "3 Двусторонняя дорога", "5 Сравнение городов", "9 Городим")*

Это самая объемная часть работы, реализованная в пакете `ru.kaufutdinova.cities`. Создана структура для представления графа городов.

*   **City (Город):**
    *   Содержит название (`name`) и карту (`HashMap`) исходящих дорог, где ключ — город-назначение, значение — цена.
    *   **Дороги:** Методы `addRoad` (двусторонняя) и `addOneWayRoad` (односторонняя) гарантируют, что дорога в один и тот же город не будет добавлена дважды, а также запрещают создание дороги в самого себя.
    *   **Сравнение (`equals` и `hashCode`):**
        *   Два города считаются равными, если у них одинаковые имена и одинаковый набор дорог.
        *   Для корректного сравнения дорог используется вспомогательная карта `Map<String, Integer>`, где ключ — имя города-назначения, а значение — цена. Это позволяет сравнивать города, даже если они являются разными объектами, но имеют одинаковые связи.
        *   `hashCode` переопределен в соответствии с `equals`.

*   **BidirectionalCity (Двусторонний город):**
    *   Наследник `City`.
    *   **Двусторонняя дорога:** Переопределяет метод `addRoad`. При вызове `cityA.addRoad(cityB, price)` он добавляет дорогу из A в B (`super.addOneWayRoad`) и, если обратной дороги еще нет, добавляет дорогу из B в A с той же ценой.

*   **Route (Маршрут):**
    *   Содержит города отправления (`from`) и назначения (`to`). Проверяет их на `null`.
    *   **Поиск пути:** Метод `findPath()` реализует **поиск в ширину (BFS)**. Этот алгоритм гарантирует нахождение пути с наименьшим количеством промежуточных городов (т.е. самого короткого в смысле количества шагов).
    *   Результат возвращается в виде массива `City[]` или пустого массива, если путь не найден.
    *   `toString()` возвращает красивое строковое представление маршрута.

**Демонстрация в `Main`:**
*   **С вводом пользователя:** Создаются два города и дорога между ними по введенным данным (с проверкой названия и цены). Строится и выводится маршрут.
*   **Предопределенный граф ("Городим"):** Создается граф, изображенный на рисунке к заданию. В нем используются как обычные города (`City`), так и двусторонние (`BidirectionalCity`). Для нескольких пар городов демонстрируется поиск маршрута.
    *   *Пример:* Поиск пути из D в A и из C в D (где пути быть не должно).

---

## 4. Птицы
*(Задача "3 Птицы")*

В пакете `ru.kaufutdinova.birds` создана простая иерархия.

*   **Bird (Птица):**
    *   Абстрактный класс.
    *   Содержит абстрактный метод `sing()`, который обязывает всех потомков реализовать "пение".
*   **Sparrow (Воробей):**
    *   Реализует `sing()`, выводя на экран `"чырык"`.
*   **Cuckoo (Кукушка):**
    *   Использует `Random` для генерации числа от 1 до 10.
    *   В цикле выводит `"ку-ку"` нужное количество раз, разделяя повторения пробелом.
*   **Parrot (Попугай):**
    *   Конструктор принимает текст и сохраняет его.
    *   Генерирует случайное число N от 1 до длины текста.
    *   Выводит первые N символов текста.

**Демонстрация в `Main`:** Создаются объекты всех трех птиц, и для каждой вызывается метод `sing()`. Для попугая пользователь вводит текст с клавиатуры.

---

## 5. Вспомогательные классы и утилиты
*(Задачи "3 Возведение в степень")*

В пакете `ru.kaufutdinova.utils` собраны вспомогательные классы.

*   **MathUtils:**
    *   Содержит статический метод `power(String xStr, String yStr)`.
    *   **Короткие имена:** В коде используется статический импорт (`import static java.lang.Integer.parseInt;`, `import static java.lang.Math.pow;`), что позволяет вызывать `parseInt` и `pow` без указания имени класса.
*   **Check:** Содержит методы для валидации ввода целых чисел и непустых строк.
*   **ForPoint:** Содержит метод для безопасного ввода координат (чисел с плавающей точкой).

**Демонстрация в `Main`:** В конце работы программа проверяет аргументы командной строки (`args`). Если их два, они передаются в метод `MathUtils.power`, и результат выводится на экран.

---

