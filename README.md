# Вариант 5
# Реализация обобщенных классов и утилитных методов

## Задача 1: Обобщенная коробка

**Задача:** Необходимо реализовать класс таким образом, чтобы он мог хранить один произвольный объект, обеспечивать его извлечение с обнулением ссылки, проверку на заполненность и выбрасывать исключение при попытке положить объект в уже заполненную коробку.

**Решение:**
- Создан обобщенный класс `Box<T>` с приватным полем `item` типа `T`
- Метод `put(T item)` проверяет, не заполнена ли коробка, и либо сохраняет объект, либо выбрасывает `IllegalStateException`
- Метод `get()` возвращает объект и обнуляет ссылку на него в коробке
- Метод `isEmpty()` проверяет, пуста ли коробка
- **Демонстрация:** Взаимодействие с пользователем через консоль:
  - Создание пустой коробки для целых чисел `Box<Integer>`
  - Запрос у пользователя числа через `readIntInput()` с обработкой некорректного ввода
  - Помещение числа в коробку с отображением текущего состояния
  - Попытка положить второе число для демонстрации исключения `IllegalStateException`
  - Извлечение числа и показ пустой коробки

## Задача 2: Хранилище без null

**Задача:** Необходимо реализовать неизменяемое хранилище, которое при создании принимает объект и альтернативное значение, а при получении возвращает либо сохраненный объект, либо альтернативу если сохранен null.

**Решение:**
- Создан обобщенный класс `Storage<T>` с final полями `item` и `alternative`
- Конструктор инициализирует оба поля при создании объекта
- Метод `get()` возвращает `item` если он не `null`, иначе возвращает `alternative`
- **Демонстрация:** Четыре интерактивных примера с вводом данных:
  1. Хранилище чисел с `null` (альтернатива 0) - демонстрация возврата альтернативы
  2. Хранилище чисел со значением от пользователя (альтернатива -1) - возврат основного значения
  3. Хранилище строк с `null` (альтернатива "default") - демонстрация работы со строками
  4. Хранилище строк с вводом от пользователя - показ обработки строковых данных

## Задача 3.1: Функция (map)

**Задача:** Необходимо реализовать метод, который принимает список значений типа T и функцию преобразования, применяет функцию к каждому элементу и возвращает новый список типа R.

**Решение:**
- Создан обобщенный метод `map()` с двумя type parameters `T` и `R` в классе `GenericUtils`
- Реализован интерфейс `Function<T, R>` с методом `apply(T t)`
- В методе создается новый список, куда добавляются результаты применения функции к каждому элементу исходного списка
- **Демонстрация:** Три интерактивных примера с полным вводом данных:
  1. **Преобразование строк в их длины:** 
     - Ввод списка строк через запятую (например: "qwerty,asdfg,zx")
     - Применение функции `String::length` через анонимный класс
     - Вывод исходного списка и списка длин
  2. **Преобразование чисел в абсолютные значения:**
     - Ввод списка чисел через запятую
     - Применение функции `Math::abs` для получения модулей чисел
     - Вывод исходных и преобразованных значений
  3. **Преобразование массивов в их максимальные значения:**
     - Ввод массивов целых чисел через запятую с пробелами внутри массивов
     - Использование `Arrays.stream().max()` для нахождения максимума
     - Форматированный вывод массивов и их максимальных значений через `arraysToString()`

## Задача 3.2: Фильтр

**Задача:** Необходимо реализовать метод, который принимает список значений типа T и предикат, возвращает новый список только с теми элементами, которые удовлетворяют условию предиката.

**Решение:**
- Создан обобщенный метод `filter()` с type parameter `T` в классе `GenericUtils`
- Реализован интерфейс `Predicate<T>` с методом `test(T t)`
- В методе создается новый список, куда добавляются только элементы, для которых предикат возвращает `true`
- **Демонстрация:** Три интерактивных примера:
  1. **Фильтрация строк по длине ≥ 3:**
     - Ввод строк через запятую
     - Использование предиката `s.length() >= 3`
     - Вывод отфильтрованных строк
  2. **Фильтрация положительных чисел:**
     - Ввод чисел через запятую
     - Использование предиката `n > 0`
     - Вывод положительных чисел
  3. **Фильтрация массивов без положительных элементов:**
     - Ввод массивов целых чисел (формат: "числа через пробел, массивы через запятую")
     - Использование `Arrays.stream().allMatch(n -> n <= 0)` для проверки отсутствия положительных элементов
     - Форматированный вывод через `arraysToString()`

## Задача 3.3: Сокращение (reduce)

**Задача:** Необходимо реализовать метод, который принимает список значений типа T, бинарный оператор и начальное значение, последовательно применяет оператор к элементам списка и возвращает одно результирующее значение. Метод должен гарантированно не возвращать `null` для пустого списка.

**Решение:**
- Создан обобщенный метод `reduce()` с type parameter `T` в классе `GenericUtils`
- Реализован интерфейс `BinaryOperator<T>` с методом `apply(T t1, T t2)`
- Метод гарантированно не возвращает `null` для пустого списка (возвращает `identity`)
- **Демонстрация:** Три интерактивных примера:
  1. **Конкатенация строк:**
     - Ввод строк через запятую
     - Использование оператора `s1 + s2` с начальным значением `""`
     - Вывод конкатенированной строки
  2. **Суммирование чисел:**
     - Ввод чисел через запятую
     - Использование оператора `n1 + n2` с начальным значением `0`
     - Вывод суммы
  3. **Подсчет общего количества элементов во вложенных списках:**
     - Ввод вложенных списков (формат: "числа через пробел внутри списка, списки через точку с запятой")
     - Два способа решения:
       - Через создание класса-обертки `Counter` и ручной подсчет
       - Через объединение списков с помощью `reduce()` и подсчет размера результата
     - Вывод общего количества элементов

## Задача 3.4: Коллекционирование

**Задача:** Необходимо реализовать метод, который принимает список значений, поставщик результирующей коллекции и аккумулятор для добавления элементов, возвращает коллекцию сгруппированных значений.

**Решение:**
- Создан обобщенный метод `collect()` с type parameters `T` и `R` в классе `GenericUtils`
- Использованы стандартные интерфейсы `Supplier<R>` и `BiConsumer<R, T>`
- Метод создает результирующую коллекцию и добавляет в нее элементы исходного списка с помощью аккумулятора
- **Демонстрация:** Три интерактивных примера:
  1. **Разделение чисел на группы:**
     - Ввод чисел через запятую
     - Использование `Supplier<Map<String, List<Integer>>>` для создания карты с тремя категориями
     - Использование `BiConsumer` для распределения чисел по категориям: positive, negative, zero
     - Вывод сгруппированных чисел
  2. **Группировка строк по длине:**
     - Ввод строк через запятую
     - Использование `HashMap::new` как поставщика и `computeIfAbsent()` для группировки
     - Вывод строк, сгруппированных по длине
  3. **Создание множества уникальных строк:**
     - Ввод строк через запятую (с возможными дубликатами)
     - Использование `HashSet::new` как поставщика (HashSet автоматически удаляет дубликаты)
     - Использование `Set::add` как аккумулятора
     - Вывод уникального набора строк

## Особенности реализации

### Вспомогательные методы для ввода данных:

1. **`readIntInput()`** - безопасный ввод целого числа с обработкой исключений
2. **`readIntList()`** - ввод списка чисел через запятую
3. **`readStringList()`** - ввод списка строк через запятую
4. **`readArrayList()`** - ввод списка массивов целых чисел (формат: "1 2 3, -5 0 5")
5. **`readNestedList()`** - ввод вложенных списков (формат: "1 2 3; 4 5; 6 7 8 9")
6. **`arraysToString()`** - форматированный вывод списка массивов

### Ключевые концепции, реализованные в программе:

1. **Типовая безопасность (Generics):** Все классы и методы параметризованы типами `<T>`, `<R>`
2. **Функциональные интерфейсы:** Использование `Function<T,R>`, `Predicate<T>`, `BinaryOperator<T>`
3. **Лямбда-выражения и анонимные классы:** Для создания функций на месте
4. **Stream API:** Для работы с массивами и коллекциями
5. **Обработка исключений:** Защита от некорректного ввода пользователя
6. **Интерактивность:** Все данные вводятся с клавиатуры с понятными инструкциями

### Архитектурные решения:

1. **Разделение ответственности:** Отдельные файлы для интерфейсов, утилит и демонстрации
2. **Повторное использование кода:** Обобщенные методы работают с любыми типами данных
3. **Защита от ошибок:** Проверки на null, обработка исключений, валидация ввода
4. **Наглядность:** Подробные выводы состояния объектов и промежуточных результатов

Программа демонстрирует полный цикл работы с обобщенными классами и методами, от проектирования интерфейсов до практического применения с интерактивным вводом данных.
