# Реализация обобщенных классов и утилитных методов

## Задача 1: Обобщенная коробка

**Задача:** Необходимо реализовать класс таким образом, чтобы он мог хранить один произвольный объект, обеспечивать его извлечение с обнулением ссылки, проверку на заполненность и выбрасывать исключение при попытке положить объект в уже заполненную коробку.

**Решение:**
- Создан обобщенный класс `Box<T>` с приватным полем `item` типа `T`
- Метод `put(T item)` проверяет, не заполнена ли коробка, и либо сохраняет объект, либо выбрасывает `IllegalStateException`
- Метод `get()` возвращает объект и обнуляет ссылку на него в коробке
- Метод `isEmpty()` проверяет, пуста ли коробка
- Продемонстрирована работа с целочисленной коробкой: помещение числа 3, извлечение и вывод результата

## Задача 2: Хранилище без null

**Задача:** Необходимо реализовать неизменяемое хранилище, которое при создании принимает объект и альтернативное значение, а при получении возвращает либо сохраненный объект, либо альтернативу если сохранен null.

**Решение:**
- Создан обобщенный класс `Storage<T>` с final полями `item` и `alternative`
- Конструктор инициализирует оба поля при создании объекта
- Метод `get()` возвращает `item` если он не `null`, иначе возвращает `alternative`
- Продемонстрированы 4 варианта использования:
  - Хранилище чисел с null (альтернатива 0)
  - Хранилище чисел со значением 99 (альтернатива -1)
  - Хранилище строк с null (альтернатива "default")
  - Хранилище строк со значением "hello" 

## Задача 4.1: Функция (map)

**Задача:** Необходимо реализовать метод, который принимает список значений типа T и функцию преобразования, применяет функцию к каждому элементу и возвращает новый список типа R.

**Решение:**
- Создан обобщенный метод `map()` с двумя type parameters `T` и `R`
- Реализован интерфейс `Function<T, R>` с методом `apply(T t)`
- В методе создается новый список, куда добавляются результаты применения функции к каждому элементу исходного списка
- Продемонстрированы три варианта использования:
  - Преобразование списка строк в список их длин
  - Преобразование списка чисел в их абсолютные значения
  - Преобразование списка массивов в их максимальные значения

## Задача 4.2: Фильтр

**Задача:** Необходимо реализовать метод, который принимает список значений типа T и предикат, возвращает новый список только с теми элементами, которые удовлетворяют условию предиката.

**Решение:**
- Создан обобщенный метод `filter()` с type parameter `T`
- Реализован интерфейс `Predicate<T>` с методом `test(T t)`
- В методе создается новый список, куда добавляются только элементы, для которых предикат возвращает `true`
- Продемонстрированы три варианта использования:
  - Фильтрация строк длиной не менее 3 символов
  - Фильтрация положительных чисел
  - Фильтрация массивов без положительных элементов

## Задача 4.3: Сокращение (reduce)

**Задача:** Необходимо реализовать метод, который принимает список значений типа T, бинарный оператор и начальное значение, последовательно применяет оператор к элементам списка и возвращает одно результирующее значение.

**Решение:**
- Создан обобщенный метод `reduce()` с type parameter `T`
- Реализован интерфейс `BinaryOperator<T>` с методом `apply(T t1, T t2)`
- Метод гарантированно не возвращает `null` для пустого списка (возвращает `identity`)
- Продемонстрированы три варианта использования:
  - Конкатенация всех строк списка
  - Суммирование всех чисел списка
  - Подсчет общего количества элементов во вложенных списках

## Задача 4.4: Коллекционирование

**Задача:** Необходимо реализовать метод, который принимает список значений, поставщик результирующей коллекции и аккумулятор для добавления элементов, возвращает коллекцию сгруппированных значений.

**Решение:**
- Создан обобщенный метод `collect()` с type parameters `T` и `R`
- Использованы стандартные интерфейсы `Supplier<R>` и `BiConsumer<R, T>`
- Метод создает результирующую коллекцию и добавляет в нее элементы исходного списка с помощью аккумулятора
- Продемонстрированы три варианта использования:
  - Разделение чисел на положительные, отрицательные и нули
  - Группировка строк по их длине
  - Создание множества уникальных строк
