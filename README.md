
---

# Лабораторная работа 6

---

# Структура проекта

Проект состоит из следующих модулей:

- **annotations/** — пользовательские аннотации  
- **handlers/** — обработчики аннотаций  
- **model/** — классы‑демонстрации  
- **Main.java** — интерактивный интерфейс  
- **test/** — модульные тесты JUnit и Mockito  

---

# Реализованные аннотации

## 1. @Invoke
**Назначение:** автоматический вызов методов, помеченных аннотацией.

**Характеристики:**
- `@Target(METHOD)`
- `@Retention(RUNTIME)`
- без свойств

**Использование:**  
Метод, помеченный `@Invoke`, автоматически вызывается обработчиком.

**Обработчик:**  
`InvokeHandler` находит методы с `@Invoke` и вызывает их через Reflection API.

---

## 2. @Default
**Назначение:** указание класса по умолчанию.

**Характеристики:**
- `@Target({TYPE, FIELD})`
- `@Retention(RUNTIME)`
- обязательное свойство `Class<?> value()`

**Использование:**  
Аннотация ставится на класс и указывает тип по умолчанию.

**Обработчик:**  
`DefaultHandler` выводит имя класса, указанного в аннотации.

---

## 3. @ToString
**Назначение:** управление тем, какие поля попадут в строковое представление объекта.

**Характеристики:**
- `@Target({TYPE, FIELD})`
- `@Retention(RUNTIME)`
- свойство `Mode value()` (YES/NO), по умолчанию YES

**Использование:**  
Поля с `Mode.NO` исключаются из строкового представления.

**Обработчик:**  
`ToStringBuilder` формирует строку, исключая поля с `Mode.NO`.

---

## 4. @Validate
**Назначение:** хранение списка классов для проверки.

**Характеристики:**
- `@Target({TYPE, ANNOTATION_TYPE})`
- `@Retention(RUNTIME)`
- обязательное свойство `Class<?>[] value()`

**Использование:**  
Аннотация принимает массив классов.

**Обработчик:**  
`ValidateHandler` выводит список классов, указанных в аннотации.

---

## 5. @Two
**Назначение:** хранение двух обязательных значений.

**Характеристики:**
- `@Target(TYPE)`
- `@Retention(RUNTIME)`
- свойства `String first()` и `int second()`

**Использование:**  
Аннотация ставится на класс и содержит два обязательных параметра.

**Обработчик:**  
`TwoHandler` выводит оба значения.

---

## 6. @Cache
**Назначение:** указание кешируемых областей и демонстрация принципов кеширования.

**Характеристики:**
- `@Target(TYPE)`
- `@Retention(RUNTIME)`
- свойство `String[] value()` (по умолчанию пустой массив)

**Использование:**  
Аннотация ставится на класс и содержит список кешируемых областей.  
Если массив пуст — кеширование считается отключённым.

**Обработчик:**  
`CacheHandler`:

- считывает массив областей,
- выводит их пользователю,
- сообщает, если массив пуст.

**Дополнительная логика:**  
Класс `CacheDemo` содержит имитацию «дорогой» операции:

- первый вызов `loadData()` вычисляет результат,
- второй вызов возвращает уже закешированное значение.

Это демонстрируется в интерфейсе программы.

---

# Обработчики аннотаций

Каждый обработчик использует Reflection API:

- получает класс или объект,
- анализирует аннотации,
- выполняет соответствующие действия,
- выводит результат пользователю.

Обработчики:

- `InvokeHandler`
- `DefaultHandler`
- `ToStringBuilder`
- `ValidateHandler`
- `TwoHandler`
- `CacheHandler`

---

# Дружественный интерфейс (Main)

Метод `main()` реализует интерактивное меню:

```
1 — @Invoke
2 — @Default
3 — @ToString
4 — @Validate
5 — @Two
6 — @Cache
0 — Выход
```

Пользователь может:

- выбрать демонстрацию любой аннотации,
- вводить данные (например, имя/возраст/город для @ToString),
- получать подробные пояснения,
- видеть результаты работы обработчиков.

Реализована проверка входных данных:

- ввод только чисел,
- обработка ошибок,
- очистка буфера ввода.

## Демонстрация @Cache в интерфейсе

При выборе пункта **6** программа:

1. выводит список кешируемых областей из аннотации,  
2. создаёт объект `CacheDemo`,  
3. вызывает `loadData()` дважды:  
   - первый вызов имитирует дорогую операцию,  
   - второй возвращает кешированное значение.

Это позволяет наглядно увидеть разницу между вычислением и кешированием.

---

# Тестирование

## Тесты для @ToString
Проверяют:

- что поля с `Mode.YES` попадают в строку,
- что поля с `Mode.NO` исключаются.

## Тесты для @Cache
Проверяют:

- корректность чтения массива областей,
- поведение при пустом массиве,
- мок‑тест с Mockito, имитирующий обращение к кешу.

Мок‑тест подменяет метод `loadData()` и проверяет, что:

- возвращается подменённое значение,
- метод действительно был вызван.

---
